---
description: 
globs: 
alwaysApply: false
---
---
description: Tracking of bugs, fixes, and ongoing issues
globs: 
alwaysApply: false
---

# Fixed Issues

## UI/Display Issues
- ✅ Progress dialog not showing during file loading
  - Fixed by ensuring the dialog is created with the right settings in MainWindow._on_load_started
  - Set minimum duration to 0 to show immediately
  - Added explicit visibility commands

- ✅ Data not displaying in table view after loading
  - Fixed the DataView._update_view method to correctly display data from the model
  - Added clearer logs to trace data flow
  - Improved error handling in update methods

- ✅ Multiple file import crashing
  - Fixed progress handling in MultiCSVLoadTask
  - Improved error resilience in _on_load_progress method
  - Added proper error handling for the progress dialog updates

- ✅ Progress dialog consistency issues
  - Enhanced MainWindow._on_load_progress to provide consistent information
  - Added proper tracking of file count, current file, and row progress
  - Improved visibility handling to ensure dialog stays visible throughout the loading process
  - Added more descriptive messages showing file progress (x/y) and row count

- ✅ SyntaxError in progress_bar.py
  - Fixed by removing extraneous backticks (```) at the end of the file
  - This was causing the application to fail at startup

- ✅ Incorrect import in main_window.py
  - Fixed incorrect import path for DataView module
  - Changed from 'chestbuddy.ui.widgets.data_view' to 'chestbuddy.ui.data_view'

- ✅ Missing color constant in progress_dialog.py
  - Fixed reference to non-existent color constant TEXT_PRIMARY
  - Changed to use TEXT_LIGHT which is available in the Colors class

- ✅ Progress dialog not closing properly after table population
  - Fixed the ProgressDialog._on_cancel_clicked method to always close the dialog after emitting the canceled signal
  - Simplified the ProgressDialog.close() method to avoid disconnecting critical signals
  - Updated MainWindow._finalize_loading to avoid breaking the cancel button functionality

- ✅ Multiple dialogs appearing during CSV import
  - Fixed by ensuring only one dialog is used throughout the entire import process
  - Modified DataManager._on_csv_load_success to prevent showing dialog for table population
  - Updated MainWindow._on_load_finished to keep the dialog open for user confirmation

- ✅ Progress dialog inappropriately showing table population status
  - Modified MainWindow._on_load_finished to keep the dialog open for explicit user confirmation
  - Ensured cancel button is renamed to "Close" once loading completes
  - Dialog no longer automatically closes, allowing users to review final status

- ✅ Table repopulating multiple times when importing multiple files
  - Fixed by removing explicit data_changed.emit() call in DataManager._on_csv_load_success 
  - The update_data method already emits this signal internally when signals are unblocked
  - This was causing the data view to update and repopulate the table multiple times unnecessarily

- ✅ Table not populating after importing files
  - Fixed by modifying ChestDataModel._calculate_data_hash to better handle empty vs non-empty DataFrames
  - Added _calculate_hash_for_empty method to provide consistent hash for empty state
  - Added special handling in update_data to force hash refresh during empty → populated transitions
  - This ensured that data_changed signal was properly emitted when loading data for the first time

- ✅ Multiple table population during file imports
  - Fixed by disconnecting the DataManager.data_loaded signal from MainWindow.populate_data_table method
  - Modified the MainWindow._finalize_loading method to explicitly call populate_data_table only once
  - This ensures the table is populated only once after all files are loaded, improving performance
  - Prevents UI slowdowns during multi-file imports

- ✅ Missing menu actions causing app startup errors
  - Fixed missing _export_validation_action and _about_action in MainWindow class
  - Added proper initialization of the export validation action in the Data menu
  - Changed instantiation of about_action to store it in self._about_action for proper signal connections
  - Improved signal connections in _connect_signals method to verify action existence before connecting

- ✅ Type annotation issues in ViewStateController
  - Fixed type annotations to use built-in Python types instead of typing module equivalents
  - Changed `Dict` to `dict`, `List` to `list`, `Set` to `set` throughout the controller
  - Updated signal parameter type annotations to ensure PySide6 compatibility
  - Added comprehensive type annotation tests to validate correct types are used
  - This prevents issues with PySide6 signals that can't handle typing module types

## Background Processing Issues
- ✅ Signal connections not working properly
  - Fixed connections between DataManager and MainWindow
  - Enhanced signal handling with proper debug logs
  - Improved DataManager._connect_signals() method

- ✅ Progress not updating during file load
  - Fixed by modifying the MultiCSVLoadTask to use a consistent scale
  - Implemented better file-specific progress reporting
  - Added overall progress updates at appropriate points

- ✅ Background worker cleanup issues
  - Improved thread cleanup in BackgroundWorker.__del__
  - Added better error handling for worker cleanup
  - Eliminated forced thread termination during shutdown

- **App crashes during CSV file import**: The application would crash in the middle of processing CSV files, particularly with large files.
  - Fixed by improving the memory management in `csv_service.py`, particularly the `read_csv_chunked` method which now incrementally processes chunks instead of storing all in memory.
  - Added robust error handling for memory errors, allowing partial data recovery.
  - Reduced UI update frequency in progress callbacks to prevent overwhelming the event queue.
  - Improved thread safety and signal handling for cross-thread communication.
  - Added proper resource cleanup and signal disconnection in the `BackgroundWorker` class.
  - Added safeguards against invalid configuration values like chunk size.

## Data Handling Issues
- ✅ ChestDataModel.update_data not notifying correctly
  - Fixed notification logic to ensure data changes are properly communicated
  - Added more detailed logging for debugging

# Remaining Issues

## Minor Issues
- QThread object deletion warning at shutdown
  - Non-critical issue related to Background Worker cleanup
  - Only occurs during application shutdown and doesn't affect functionality
  - Implemented a more graceful shutdown process to avoid thread termination
  - Improved warning messages to debug level to avoid alarming users

- **Memory usage during large file imports**: While improved, importing very large files still requires significant memory. 
  - Could be further improved by implementing disk-based intermediate storage for extremely large datasets.

- **UI responsiveness during intensive operations**: Very large datasets (50,000+ rows) can occasionally cause UI freezing despite background processing.
  - Additional throttling and chunking mechanisms could improve this further.

## Current Technical Challenges

- **Report generation**: Design and implementation of the PDF export functionality
  - Need to select appropriate PDF generation library
  - Challenge with embedding charts with proper resolution
  - Handling pagination for large reports

- **Settings persistence**: More robust storage of application settings
  - Ensuring backward compatibility when adding new settings
  - Providing defaults for missing settings
  - Supporting user profiles in the future

- **Enhanced error recovery**: More sophisticated error recovery mechanisms
  - Providing better options to users when errors occur
  - Preserving partial data when possible
  - Automatic recovery attempts for common issues

## Lessons Learned

1. Signal connections require careful debugging to ensure they're properly connected and functioning
2. Progress reporting should have consistent scales and clear distinction between file-specific and overall progress
3. The Qt progress dialog requires explicit visibility commands in some cases
4. Background task error handling is critical for preventing crashes during file operations
5. Debug logging in key methods greatly assists troubleshooting complex interaction issues
6. Thread cleanup during application shutdown requires special handling to avoid errors
7. Tracking state in a dedicated dictionary (_loading_state) provides more consistent UI updates
8. Processing events (QApplication.processEvents()) is important for responsive UI updates during file operations
9. Check Python files for syntax errors such as extraneous code block markers (```) or incorrect indentation
10. Verify color constants and other resources exist before using them in UI components
11. Keep import paths consistent with actual project structure
12. Use built-in Python types (dict, list) instead of typing module equivalents (Dict, List) for PySide6 signals

- **Memory Management Patterns**: Accumulating chunks of data in memory can lead to crashes with large files. Instead:
  - Process data incrementally where possible
  - Implement early exit strategies for memory errors
  - Add progress throttling to reduce overhead
  - Consider using disk-based intermediate storage for very large datasets

- **Signal Safety**: When working with signals across threads:
  - Use robust error handling around every signal emission
  - Implement throttling for high-frequency progress updates
  - Always disconnect signals when done to prevent memory leaks
  - Use try/except blocks around Qt object interactions that might be deleted

## [2025-03-24] CSV Loading Error

### Issue
CSV loading functionality was failing with an error:
```
Error setting up CSV loading task: BackgroundWorker.execute_task() takes 2 positional arguments but 3 were given
```

### Root Cause
During implementation of progress dialog improvements, the DataManager.load_csv method was modified to call `self._worker.execute_task(task, result_key)` with three arguments, but the BackgroundWorker.execute_task method only accepts two parameters (self and task).

### Solution
1. Fixed the DataManager.load_csv method to call execute_task correctly:
   ```python
   # Changed from
   result_key = "load_csv"
   self._worker.execute_task(task, result_key)
   
   # To
   self._worker.execute_task(task)
   ```

2. Updated the BackgroundWorker._on_thread_started method to properly emit the task_completed signal with the task ID after completion:
   ```python
   task_id = getattr(self._task, "task_id", "unknown")
   self.finished.emit(result)
   self.task_completed.emit(task_id, result)
   ```

3. Enhanced the DataManager._on_background_task_completed method to better handle task results:
   ```python
   if isinstance(result, tuple) and len(result) == 2:
       success, data_or_error = result
       if success and isinstance(data_or_error, pd.DataFrame):
           # Handle successful CSV load
           self._on_csv_load_success((data_or_error, None))
       else:
           # Handle CSV load error
           error_msg = data_or_error if isinstance(data_or_error, str) else str(data_or_error)
           self._on_csv_load_success((None, error_msg))
   ```

### Verification
Tested by loading multiple CSV files, which now works correctly with proper progress reporting.

## [2025-03-25] ViewStateController Type Annotation Issues

### Issue
The ViewStateController was using typing module type annotations (Dict, List, Set) which are incompatible with PySide6 signals that expect built-in Python types.

### Root Cause
PySide6 signals cannot properly handle typing module types like Dict, List, and Set. When a signal emits a value with these types, it can cause type errors or serialization issues.

### Solution
1. Updated all type annotations in ViewStateController to use built-in Python types:
   ```python
   # Changed from
   self._view_dependencies: Dict[str, Set[str]] = {}
   self._view_prerequisites: Dict[str, List[Callable]] = {}
   self._view_availability: Dict[str, bool] = {}

   # To
   self._view_dependencies: dict[str, set[str]] = {}
   self._view_prerequisites: dict[str, list[Callable]] = {}
   self._view_availability: dict[str, bool] = {}
   ```

2. Updated class docstring to reflect the correct types:
   ```python
   """
   Attributes:
       _view_dependencies (dict[str, set[str]]): View dependencies (key depends on values)
       _view_prerequisites (dict[str, list[Callable]]): View prerequisites functions
       _view_availability (dict[str, bool]): Current availability of views
   """
   ```

3. Created comprehensive type annotation tests that verify:
   - Signal documentation uses correct types
   - Attributes use built-in Python types
   - Method parameters use built-in Python types
   - Emitted signal values are properly typed

### Verification
Created and implemented `tests/core/controllers/test_view_state_controller_type_annotations.py` which verifies all type annotations are compatible with PySide6 signals. All tests pass successfully.

### Lessons Learned
1. Always use built-in Python types (dict, list, set) instead of typing module equivalents (Dict, List, Set) when working with PySide6 signals
2. Create dedicated tests for type annotations when working with cross-language bindings like PySide6
3. Document signal parameter types clearly in docstrings using consistent syntax

# Bug Tracking and Fixing Log

This document tracks bugs, issues, and their solutions in ChestBuddy.

## Active Issues

1. ~~**Table repopulation on view switch** - When switching views, the table is unnecessarily repopulated even if the data hasn't changed.~~
   - Status: Fixed
   - Solution: Modified `DataViewAdapter.needs_refresh()` to check data dimensions before refreshing and added proper refresh handling in `MainWindow.refresh_ui()`.

2. ~~**Data table not refreshing on new file imports** - When importing new files after an initial import, the data view doesn't properly refresh.~~
   - Status: Fixed
   - Solution: Modified `ChestDataModel` to expose the data hash via a new property (`data_hash`) and updated `DataViewAdapter.needs_refresh()` to check for data content changes using this hash in addition to dimension changes.

## Fixed Issues

### Bug: Table repopulation on view switch

**Description:**
When switching between views (e.g., from Data view to Dashboard and back), the table is unnecessarily repopulated even if the data hasn't changed, causing performance issues.

**Root Cause:**
The `refresh_ui()` method in `MainWindow` was refreshing the data view every time, regardless of whether the data had changed. The adapter class lacked proper state tracking to prevent unnecessary refreshes.

**Solution:**
1. Added a `needs_refresh()` method to `DataViewAdapter` to check if the data dimensions have changed
2. Updated `refresh_ui()` in `MainWindow` to only call `refresh()` on the adapter if needed
3. Added state tracking in `DataViewAdapter` to compare current and previous data state

**Resolved:** March 24, 2025

### Bug: Data table not refreshing on new file imports

**Description:**
When importing new files after an initial import, the data view doesn't update to show the new data if the dimensions (row/column count) remain the same.

**Root Cause:**
The `needs_refresh()` method in `DataViewAdapter` only checked for changes in dimensions (row count and column count). When loading a new file with the same number of rows and columns, it couldn't detect that the data content itself had changed.

**Solution:**
1. Added a new `data_hash` property to `ChestDataModel` to expose the internal hash-based data change detection
2. Updated `DataViewAdapter._update_data_state()` to store the current data hash
3. Modified `DataViewAdapter.needs_refresh()` to check both dimensions and data hash changes
4. This ensures the data view detects all data changes, even when dimensions remain the same

**Resolved:** March 24, 2025

### Bug: Data view not refreshing when selecting another file

**Description:**
When a user loads data and then selects another file, the table in the Data view didn't update to show the new data, even though the data model was updated correctly.

**Root Cause:**
In `MainWindow._ensure_data_table_populated`, when the user was not on the Data view, the code was calling `data_view._update_data_state()` which prematurely updated the state tracking. This caused the data view to incorrectly think it was already up to date when switching to it later, resulting in the table not refreshing.

**Solution:**
1. Added a `_needs_population` flag to `DataViewAdapter` to track when the table needs population even if state tracking suggests otherwise
2. Modified `MainWindow._ensure_data_table_populated` to set the `needs_population` flag instead of updating state tracking when not on the Data view
3. Updated `MainWindow._set_active_view` to check this flag when activating the Data view and populate the table if needed
4. This ensures that when data changes while the user is not on the Data view, the table will be refreshed when switching to it later

**Resolved:** March 24, 2025

## Known Limitations

1. **Memory usage with large datasets** - Loading very large datasets (>100k rows) can be memory-intensive
   - Status: To be optimized
   - Potential solution: Implement data paging/virtualization

2. **UI responsiveness during data loading** - UI can become less responsive during loading of large files
   - Status: Partially mitigated
   - Current solution: Background processing with progress reporting
   - Further improvements planned: Chunked processing with yield points for UI updates

## Recent Fixes

### Type Annotation Fix for PySide6 Signals (2024-03-29)

**Issue**: PySide6 signal handling in ViewStateController and related classes was causing issues due to incorrect type annotations - using `typing.Dict` instead of Python built-in `dict` type.

**Fix**: 
- Updated imports to remove `Dict` from typing imports in affected files
- Changed signal annotations from `@Slot(Dict)` to `@Slot(dict)` 
- This ensures proper type compatibility with PySide6's signal/slot mechanism
- Files updated:
  - chestbuddy/ui/widgets/sidebar_navigation.py
  - chestbuddy/core/controllers/view_state_controller.py (already using correct annotation)
  - chestbuddy/ui/main_window.py (already using correct annotation)

**Impact**: This improves type-checking consistency and prevents potential signal connection issues. We should ensure that all PySide6 signals use Python's built-in types rather than typing equivalents.
