---
description: Tracking of bugs, fixes, and ongoing issues
globs: 
alwaysApply: false
---

## Resolved Issues

### 2024-03-26: Fixed TypeError in test_update_manager_data_dependency_integration.py
- **Issue**: MockUpdatable class was causing a TypeError due to metaclass conflict when directly implementing IUpdatable interface
- **Fix**: Modified MockUpdatable to inherit from UpdatableComponent base class instead of directly implementing IUpdatable
- **Related Changes**: 
  - Updated test methods to use correct methods: `schedule_update` instead of `register_component`
  - Updated test methods to use `process_pending_updates` instead of `_process_updates`
- **Status**: Fixed, all tests in this file now pass

### 2024-03-26: Fixed Double Table Population Issue When Loading CSV Files
- **Issue**: When loading CSV files, the table was being populated twice due to duplicate signal connections
- **Root Cause**: `DataManager` was connecting both the `task_completed` signal and the `finished` signal from `BackgroundWorker`, both of which triggered similar processing paths leading to duplicate calls to `_on_csv_load_success`
- **Fix**: Removed the redundant connection of `worker.finished` to `_adapt_task_result` in the `_connect_signals` method, retaining only the more specific `task_completed` signal connection
- **Implementation**: Modified `data_manager.py` to comment out the duplicate signal connection in the `_connect_signals` method
- **Status**: Fixed, CSV files now load correctly without duplicate table population

### 2024-03-28: Fixed Change Detection Issue in ChestDataModel
- **Issue**: ChestDataModel wasn't properly detecting changes and emitting signals when updating data
- **Fix**: Enhanced the _notify_change and update_data methods to ensure data changes are correctly detected and signals are emitted
- **Related Changes**:
  - Updated integration tests to properly validate the change detection
  - Used correct column references in tests to ensure proper data validation
- **Status**: Fixed, all integration tests now pass successfully

### 2024-03-28: Fixed QThread Object Deletion Warning
- **Issue**: Minor QThread object deletion warning at shutdown
- **Fix**: Ensured proper thread cleanup in the UpdateManager before application shutdown
- **Status**: Fixed, no more warnings during application shutdown

### 2024-03-28: Updated Controller Tests for QApplication
- **Issue**: Some controller tests that required QApplication needed to be updated to use pytest-qt
- **Fix**: Refactored tests to properly use the pytest-qt plugin for QApplication setup
- **Status**: Fixed, all controller tests now run correctly

## 2025-03-26: Double Table Population Issue

### Problem
When data was loaded in the ChestBuddy application, the data table would sometimes be populated twice, especially when switching to the Data view before the initial population was complete. This caused performance issues and potential UI inconsistencies.

### Root Cause
We identified that there were two parallel signal paths leading to table population:
1. The `DataView` directly connected to the `ChestDataModel.data_changed` signal, triggering `_update_view`
2. The `DataViewAdapter` connected to the same signal, and would also trigger population through the `UpdateManager`

This dual pathway led to duplicate population in some edge cases, especially during view transitions.

### Solution
Modified `DataViewAdapter.__init__` to disable auto-update on the underlying `DataView`:
```python
# Create the underlying DataView
self._data_view = DataView(data_model)
# Disable auto-update to prevent double population
self._data_view.disable_auto_update()
```

This change ensures that all updates go through the `DataViewAdapter` and the `UpdateManager`, preventing the `DataView` from responding directly to `data_changed` signals, which eliminated the duplicate population issue.

### Testing
We verified that the table population occurs exactly once when loading data and switching between views. The log shows:
```
2025-03-26 05:04:50,181 - chestbuddy.ui.data_view - DEBUG - Auto-update disabled, skipping table update
```
Which confirms that the DataView is no longer reacting to direct data change events.

## 2025-03-26: Fixed Missing Auto-Update in DataViewAdapter

### Problem
After fixing the double table population issue, we encountered a new problem where data wouldn't automatically load in the DataView at all, requiring manual refresh to see any data.

### Root Cause
When we disabled auto-update on the DataView to prevent double population, we didn't ensure that the DataViewAdapter itself had auto-update enabled to receive and process data change events through the proper channel (UpdateManager).

### Solution
Modified `DataViewAdapter.__init__` to explicitly enable auto-update on the adapter itself after disabling it on the DataView:
```python
# Create the underlying DataView
self._data_view = DataView(data_model)
# Disable auto-update to prevent double population
self._data_view.disable_auto_update()
# Ensure the adapter itself has auto-update enabled
self.enable_auto_update()
```

This change ensures that:
1. The DataView doesn't respond directly to data change events (preventing double population)
2. The DataViewAdapter properly receives and processes data change events through the UpdateManager
3. Data is automatically loaded and displayed without manual intervention

### Testing
We verified that:
- Data now correctly loads automatically when files are opened
- There is still no double population of the table
- The user experience is seamless, with data appearing as expected without manual refreshes

## 2025-03-26: Fixed DataViewAdapter Initialization Order Issue

### Problem
After adding auto-update to the DataViewAdapter, the application would fail to start with an error:
```
Failed to create UI: 'DataViewAdapter' object has no attribute '_signal_manager'
```

### Root Cause
We were calling `self.enable_auto_update()` in the DataViewAdapter's `__init__` method before the parent class constructor (`super().__init__()`) was called. Since the `_signal_manager` attribute is initialized in the parent class, it wasn't available yet when we tried to use it.

### Solution
Moved the `self.enable_auto_update()` call to after the `super().__init__()` call in DataViewAdapter's `__init__` method:
```python
# Create the underlying DataView
self._data_view = DataView(data_model)
# Disable auto-update to prevent double population
self._data_view.disable_auto_update()

# Initialize the base view with debug mode option
super().__init__("Data View", parent, debug_mode=debug_mode)
self.setObjectName("DataViewAdapter")

# Ensure the adapter itself has auto-update enabled
self.enable_auto_update()
```

This fix ensures that all parent class initialization (including the creation of the `_signal_manager`) happens before we try to use it in the `enable_auto_update()` method.

### Testing
We verified that:
- The application starts correctly without errors
- Auto-update functionality works as expected
- Data is displayed automatically when files are opened
- No double population occurs

## Ongoing Issues

All known issues have been resolved. The application is now stable and ready for release.

## 2025-03-26: Fixed DataView Import Button Not Working

### Problem
The import button in the DataView was not functioning correctly. Clicking it did not open a file dialog as expected, even though the import functionality worked correctly in other parts of the application like the Dashboard.

### Root Cause
We identified several issues in the signal chain:

1. The `ActionButton` class had an inconsistency between its `name()` method and how the `get_button_by_name()` method in `ActionToolbar` was accessing button names (as attributes vs. method calls)
2. The `_on_import_clicked` method in `DataView` had complex conditional checks and parent chain traversal that were preventing the signal from being emitted
3. An incorrect attempt to use `SignalManager.disconnect_all()` with multiple parameters was causing errors in the signal connection
4. A fallback mechanism in `DataViewAdapter._on_import_requested` was causing a second file dialog to open after the first one

### Solution

1. Fixed the `ActionButton` class to provide a consistent way to access button names:
   ```python
   # Make name accessible as an attribute as well for compatibility
   self.name = name
   ```

2. Simplified the `_on_import_clicked` method in `DataView` to simply emit the signal:
   ```python
   def _on_import_clicked(self):
       """Handle import button click."""
       # Simply emit the signal to be handled by the adapter
       self.import_clicked.emit()
   ```

3. Fixed the signal connections in `DataViewAdapter._connect_ui_signals()` to use direct Qt connections:
   ```python
   # Connect the import button signal
   self._data_view.import_clicked.connect(self._on_import_requested)
   ```

4. Removed the fallback mechanism from `DataViewAdapter._on_import_requested`:
   ```python
   def _on_import_requested(self):
       """Handle import button click."""
       # Simply emit the signal to be handled by MainWindow
       self.import_requested.emit()
   ```

### Testing
We verified that:
- The import button in DataView now works correctly, opening a single file dialog
- The signal chain flows properly: Button click → DataView → DataViewAdapter → MainWindow → FileController
- No duplicate file dialogs are opened
- All tests related to DataViewAdapter still pass

## 2025-03-26: Code Cleanup - Removed Obsolete DataViewAdapter Fragment

### Description
Identified and removed an outdated partial implementation of `DataViewAdapter` in `chestbuddy/ui/data_view_adapter.py`. This file contained only two methods (`needs_refresh` and `refresh`) and was not being imported or used by any other code in the project.

### Analysis
- The file appeared to be a fragment from an earlier implementation.
- No other files were importing or referencing it.
- The functionality has been properly implemented in the newer `chestbuddy/ui/views/data_view_adapter.py` module.
- The modern implementation includes similar methods (`needs_update` and `refresh`) with improved functionality.

### Action Taken
- Verified through code search that no imports or dependencies existed.
- Removed the file to avoid confusion and maintain a cleaner codebase.
- Kept the `chestbuddy/ui/data_view.py` file as it is still actively used by the new adapter.

### Impact
- No functional impact; this was purely a code cleanup operation.
- Reduces potential confusion during future development.
- Maintains a cleaner codebase by removing obsolete fragments.

